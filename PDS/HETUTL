HETUTL   TITLE    'Convert tape to HET format'
*| ====================================================================
*| Function : Convert tapes to Hercules Emulated Tape format.
*|
*| Amode    : Must run in 31-bit addressing mode
*|
*| Rmode    : Must reside below the line
*|
*| Auth     : None
*|
*| Return   : All errors are indicated with a message to SYSPRINT and
*|            a non-zero condition code:
*|
*|            100 = Input file open error
*|            101 = Input file read error
*|            200 = Output file open error
*|            300 = SYSIN file open error
*|            400 = Bad input parameter
*|            401 = Bad Numeric value
*|            402 = Chunk size out of range
*|            403 = Method out of range
*|            404 = Level out of range
*|            405 = Input DD name too long
*|            406 = Output DD name too long
*|            407 = Boolean parameter not YES or NO
*|            408 = Volser mismatch
*|            409 = Route code not within range
*|            500 = Compression failed
*|            501 = Decompression failed
*|            502 = Data blocks unequal
*|
*| Descript : This program accepts an IBM format tape and converts it
*|            to an HET format file.  Output compression, input block
*|            sizes of up to 65535 bytes, and options to create files
*|            compatible with the AWSTAPE format are supported.
*|
*| Execparm : Specify "ABEND" to force the program to abend instead of
*|            return a condition code in the event of an error.
*|
*| Parms    : Blank delimited keyword/value pairs.
*|
*|            INPUT_DDNAME <x>
*|                DD name of input data set.
*|
*|                Default: SYSUT1
*|
*|            OUTPUT_DDNAME <x>
*|                DD name of output data set.
*|
*|                Default: SYSUT2
*|
*|            CHUNK_SIZE <n>
*|                Physical output blocks will be broken into <n> sized
*|                chunks.  Setting this parameter to 4096 and turning
*|                off compression will create output compatible with
*|                the AWSTAPE format.
*|
*|                Minimum: 4096
*|                Maximum: 65535
*|                Default: 65535
*|
*|            COMPRESSION_METHOD <0|1|2>
*|                Specifies whether compression should be performed and
*|                which method to use.  See note above about AWSTAPE
*|                format compatiblity.
*|
*|                Values:  0 - No compression
*|                         1 - ZLIB compression
*|                         2 - BZLIB compression
*|                Default: 1 - ZLIB compression
*|
*|            COMPRESSION_LEVEL <n>
*|                Level of compression performed.  Setting <n> to lower
*|                values decreases compression effectiveness, but will
*|                improve run times.
*|
*|                Minimum: 1 - Fastest compression
*|                Maximum: 9 - Best compression
*|                Default: 4 - Middle of the road
*|
*|            VERIFY_COMPRESSION <YES|NO>
*|                Decompress data after compression and compare against
*|                input data.
*|
*|                Values:  YES - Verify compression
*|                         NO  - Bypass verification
*|                Default: NO  - Bypass verification
*|
*|            CHECK_VOLSER <YES|NO>
*|                Verify volser from VOL1 against the one requested.
*|
*|                Values:  YES - Check the volsers
*|                         NO  - Bypass check
*|                Default: NO  - Bypass check
*|
*|            CLEAR_IDRC_INDICATOR <YES|NO>
*|                Clear the IDRC indicator in the VOL1 record.
*|
*|                Values:  YES - Clears IDRC indicator in VOL1
*|                         NO  - Ignore the indicator
*|                Default: NO  - Ignore the indicator
*|
*|            DISPLAY_ENDING_STATUS <YES|NO>
*|                Display the sense information from the last read.
*|
*|                Values:  YES - Display the info
*|                         NO  - Bypass display
*|                Default: NO  - Bypass display
*|
*|            ROUTE_CODE <n>
*|                Specifies the route code to use when issuing WTORs.
*|                Multiple route codes may be specifed by including
*|                as many ROUTE_CODE statements as needed.
*|
*|                Minimum: 1
*|                Maximum: 128
*|                Default: 3 (Tape Pool)
*|
*| Example  : //HETUTL   EXEC PGM=HETUTL,REGION=4M<,PARM=ABEND>
*|            //STEPLIB  DD DISP=SHR,DSN=<(authorized) load library>
*|            //INDD     DD DISP=SHR,DSN=<input tape>,LABEL=(1,SL)
*|            //OUTDD    DD DISP=(,CATLG),DSN=<output data set>,
*|            //            SPACE=(CYL,(10,10)),UNIT=SYSALLDA
*|            //SYSPRINT DD SYSOUT=*
*|            //SYSIN    DD *
*|            INPUT_DDNAME        INDD
*|            INPUT_DDNAME        OUTDD
*|            COMPRESSION_LEVEL   9
*|            /*
*|
*| WTORs    : When volser checking is specifed, the following WTOR will
*|            be issued:
*|
*|            nn HETUTL vvvvvv mounted for vvvvvv.  Reply (I)gnore or
*|               (C)ancel
*|
*|            Responding cancel will terminate execution and produce an
*|            appropriate error.
*|
*|            Ignore will cause a recheck of the volume and if the same
*|            volume is still mounted, will simply ignore the mismatch
*|            and continue execution.  If a new volume is detected and
*|            another mismatch occurs, the WTOR will be re-issued.
*|
*| Notes    : The input data set must be a tape dataset.
*|
*|            The output data set may reside on DASD or TAPE and will
*|            be forced to use DCB=(RECFM=U,LRECL=0,BLKSIZE=32760).
*|
*|            The EXCP abnormal end appendage is no longer needed so
*|            the code has been removed.  This means that HETUTL no
*|            longer has any APF requirements.
*|
*|            Developed on OS/390 2.8/10, so compatibility with other
*|            or older/newer OSes is unknown.
*|
*| Thanks   : Special thanks go out to Dignus, LLC for providing a
*|            short term license of their Systems/C compiler.  Using
*|            their compiler removes any run-time library limitations
*|            and/or restrictions.  Thanks Dave!
*|
*| Changes  : 2000/12/15 - LLL - Initial version
*|            2002/01/25 - LLL - Added CHECK_VOLSER parameter
*|            2002/01/25 - LLL - Added CLEAR_IDRC_INDICATOR parameter
*|            2002/01/25 - LLL - Documented VERIFY_COMPRESSION parm
*|            2002/01/25 - LLL - Fixed error messages
*|            2002/01/28 - LLL - Added ABEND EXEC parm
*|            2002/01/29 - LLL - ERP has (finally) been disabled
*|            2002/01/30 - LLL - Case insensitve input parameters
*|            2002/02/06 - LLL - Recheck volsers after WTOR
*|            2002/02/07 - LLL - Specify route code
*|            2002/02/14 - LLL - Fix numeric argument test
*|            2002/02/17 - LLL - User selectable route codes
*|            2002/02/17 - LLL - Changed default compression level to 3
*|            2002/02/17 - LLL - Allow IDRC clear without volser check
*|            2002/02/17 - LLL - Fixed recheck after volume mismatch
*|            2002/02/17 - LLL - Added info WTO when mismatch ignored
*|            2002/02/17 - LLL - Some comments fixed
*|            2002/05/22 - LLL - Clear IDRC indicator in HDR2 also
*|
*| ====================================================================
*
* Tunable parameters
*
*----------------------------------------------------------------------
* Output chunk sizes.
*----------------------------------------------------------------------
MINCHK   EQU      4096                      Min: 4096
MAXCHK   EQU      65535                     Max: 65535
DEFCHK   EQU      MAXCHK                    Default: Maximum
*
*----------------------------------------------------------------------
* Compression levels.
*----------------------------------------------------------------------
MINLVL   EQU      1                         Min: 1
MAXLVL   EQU      9                         Max: 9
DEFLVL   EQU      3                         Default: Middle of the road
*
*----------------------------------------------------------------------
* Compression methods.
*----------------------------------------------------------------------
MINMTH   EQU      0                         Min: 0 (no compression)
MAXMTH   EQU      2                         Max: 2 (BZLIB)
DEFMTH   EQU      1                         Default: 1 (ZLIB)
*
*----------------------------------------------------------------------
* WTOR route codes.
*----------------------------------------------------------------------
MINRCD   EQU      1                         Min: 1
MAXRCD   EQU      128                       Max: 128
DEFRCD   EQU      3                         Default: (3) Tape pool
*
*----------------------------------------------------------------------
* Verify compression.
*----------------------------------------------------------------------
DEFVER   EQU      0                         Default: 0 (Bypass)
*
*----------------------------------------------------------------------
* Check volser.
*----------------------------------------------------------------------
DEFCVS   EQU      0                         Default: 0 (Bypass)
*
*----------------------------------------------------------------------
* Maximum input block size we support (do not change)
*----------------------------------------------------------------------
MAXBLK   EQU      65535                     Max: 65535
*
* Copy globals
*
         COPY     #GLOBAL
*
*----------------------------------------------------------------------
* Main Entry
*----------------------------------------------------------------------
         EXTRN    ZCMP2,BZBUFFC             Compression routines
         EXTRN    ZUNCMP,BZBUFFD            Decompression routines
HETUTL   #PROLOG  BASER=R11,MAIN=YES        Entry
HETUTL   AMODE    31                        Must be AMODE 31
HETUTL   RMODE    24                        Must be RMODE 24
         LA       R12,4095(R11)             Load second base reg
         LA       R12,1(R12)                Bump it up one more
         USING    HETUTL+4096,R12           Map us
*
* Check parm for ABEND
*
         L        R1,0(R1)                  Get parms ptr
         CLC      =H'5',0(R1)               Five bytes?
         BNE      NOTAE                     No, just ignore it
         CLC      =C'ABEND',2(R1)           "ABEND"?
         BNE      NOTAE                     No, just ignore it
         OI       FLAGS,FLAE                Set abend on error
*
* Load and map ptr to the input IOB
*
NOTAE    LA       R9,IIOB                   Get ptr to IOB
         USING    IOBSTDRD,R9               Map it
*
* Open SYSIN parameter file
*
         OPEN     (PDCB,INPUT),MODE=31      Open SYSIN file
         TM       PDCB+(DCBOFLGS-IHADCB),DCBOFOPN Did it open?
         BZ       POPERR                    No, go tell user
*
* Parameter processing loop
*
PLOOP    GET      PDCB,PREC                 Get a record from SYSIN
         CLI      PREC,C'*'                 Is first character an "*"
         BE       PLOOP                     Yep, comment card
*
* Convert to uppercase
*
         MVI      TRTABLE,C' '              Just clear...
         MVC      TRTABLE+1(255),TRTABLE    ...the table
         OC       PREC,TRTABLE              Convert to uppercase
*
* Get keyword
*
         LA       R1,PREC                   Get ptr to parm rec
         BAL      R10,GETWORD               Find blank delimited word
*
* Search table for keyword
*
         LA       R5,PTABLE-12              Get table ptr
PLFK01   LA       R5,12(R5)                 Bump to next table entry
         ICM      R2,B'1111',0(R5)          Get and test key ptr
         BZ       BADPARM                   Zero, keyword not found
         CH       R4,8(R5)                  Word length != key length?
         BNE      PLFK01                    Yes, can't match
PLFK02   CLC      0(0,R3),0(R2)             Executed
         EX       R4,PLFK02                 Word and key equal?
         BNE      PLFK01                    No, continue search
*
* Have a valid keyword so get value and process it
*
         BAL      R10,GETWORD               Find blank delimited word
         TM       10(R5),PTNUM              Number expected?
         BO       PLCVN01                   Yes, go convert number
         TM       10(R5),PTBOOL             Boolean?
         BNO      PLCV01                    No, just go call handler
*
* Validate and convert boolean value
*
         CL       R4,=F'1'                  Could it be "NO"?
         BNE      PLCVB01                   No, go check for "YES"
         CLC      =C'NO',0(R3)              Is it "NO"?
         BNE      BADBOOL                   No, go complain
         XR       R2,R2                     Result = FALSE
         B        PLCV01                    Go call handler
PLCVB01  CL       R4,=F'2'                  Could it be "YES"?
         BNE      BADBOOL                   No, go complain
         CLC      =C'YES',0(R3)             Is it "YES"?
         BNE      BADBOOL                   No, go complain
         LA       R2,1                      Result = TRUE
         B        PLCV01                    Go call handler
*
* Validate and convert numeric value
*
PLCVN01  MVI      TRTABLE,C' '              Stop on any...
         MVC      TRTABLE+1(255),TRTABLE    ...character...
         XC       TRTABLE+C'0'(10),TRTABLE+C'0' ... other than numbers
PLCVN02  TRT      0(0,R3),TRTABLE           Executed
         EX       R4,PLCVN02                Value numeric?
         BNE      BADNUM                    No, bad number
PLCVN03  PACK     PVALP,0(0,R3)             Executed
         EX       R4,PLCVN03                Pack value
         CVB      R2,PVALP                  Convert to binary
*
* Call processing routine
*
*     R2 = Numeric or boolean value (if any)
*     R3 = Ptr to value
*     R4 = Length of value - 1
*
PLCV01   L        R15,4(R5)                 Get routine ptr
         BALR     R10,R15                   Call it
*
* Processed this parameter record so continue with more
*
         B        PLOOP                     Continue parm loop
*
* End of parameter file so close it
*
PEOF     CLOSE    PDCB,MODE=31              Close SYSIN
         FREEPOOL PDCB                      Free buffer pool
*
* Set routing codes if user didn't specify any
*
         LA       R1,WTORL                  Get WTOR parm list
         USING    WPL,R1                    Map it
         TM       WPLMCSF1,WPLMCSFA         Codes already specified?
         BO       HRCD                      Yes, skip
         OI       WPLMCSF1,WPLMCSFA         Turn on routing codes
         AH       R1,WPLLGH                 Point to WPX
         DROP     R1                        Unmap
         USING    WPX,R1                    Map it
         MVC      WPXROUT+((DEFRCD-1)/8)(1),MASKS+((DEFRCD-1)-(((DEFRCDX
               -1)/8)*8))                   Set default route code
         DROP     R1                        Unmap
HRCD     DS       0H                        Already have route codes
*
* Summarize processing option for user
*
         #CALL    PRINTF,'Processing Options:\n\n'
         #CALL    PRINTF,'  Input DD name:                %-8.8s\n',   X
               =A(IDCB+(DCBDDNAM-IHADCB))
         #CALL    PRINTF,'  Output DD name:               %-8.8s\n',   X
               =A(ODCB+(DCBDDNAM-IHADCB))
         #CALL    PRINTF,'  Compression Level:            %d\n',*CPLVL
         #CALL    PRINTF,'  Compression Method:           %d\n',*CPMETH
         #CALL    PRINTF,'  Output chunk size:            %d\n',*CHKSZ
         TM       FLAGS,FLVER               Verifying compression?
         BNO      NVER0                     No, branch
         #CALL    PRINTF,'  Verifying compressed data:\n'
         #CALL    PRINTF,'\n'
NVER0    TM       FLAGS,FLCVS               Checking volsers?
         BNO      NCVS0                     No, branch
         #CALL    PRINTF,'  Checking volsers:\n'
NCVS0    #CALL    PRINTF,'\n'
*
* Get storage for input buffer
*
         #CALL    MALLOC,=A(MAXBLK)         Get storage
         ST       R15,CPIBUFP               Compression input ptr
         STCM     R15,B'0111',ICCWREAD+(CCW0ADDR-CCW0) Read buffer
*
* Get storage for compression buffer
*
         #CALL    MALLOC,=A(MAXBLK)         Get storage
         ST       R15,CPOBUFP               Compression output ptr
         ST       R15,DCIBUFP               Decompression input ptr
*
* Get storage for decompression buffer
*
         TM       FLAGS,FLVER               Verifying compression?
         BNO      NVER1                     No, branch
         #CALL    MALLOC,=A(MAXBLK)         Get storage
         ST       R15,DCOBUFP               Decompression output ptr
NVER1    DS       0H                        Target
*
* Open input file
*
         OPEN     (IDCB,INPUT),MODE=31      Open input file
         TM       IDCB+(DCBOFLGS-IHADCB),DCBOFOPN Did it open?
         BZ       IOPERR                    No, go tell user
*
* Open output file
*
         OPEN     (ODCB,OUTPUT),MODE=31     Open output file
         TM       ODCB+(DCBOFLGS-IHADCB),DCBOFOPN Did it open?
         BZ       OOPERR                    No, go tell user
*
* Setup the (de)compression routine addresses
*
         L        R1,CPMETH                 Get compression method
         SLL      R1,2                      Calc table index
         L        R2,CPTAB(R1)              Get routine addr
         ST       R2,CPRTN                  Save addr
         L        R2,DCTAB(R1)              Get routine addr
         ST       R2,DCRTN                  Save addr
*
* Rewind the tape
*
RW01     LA       R1,ICCWREW                Get CCW ptr
         ST       R1,IOBSTART               Set in IOB
         XC       IECB,IECB                 Reset ECB
         LA       R0,IIOBE                  Get ptr to IOBE
         EXCP     IIOB                      Start the commnad
         WAIT     ECB=IECB                  Wait for rewind to finish
*
* Prepare for read
*
         LA       R1,ICCWREAD               Get CCW ptr
         ST       R1,IOBSTART               Set in IOB
*
* Need to verify volser or clear VOL1 IDRC indicator byte?
*
         TM       FLAGS,FLCVS+FLCII         Check volser or clear IDRC?
         BZ       RLOOP                     No, bypass check
*
* Read first block
*
         XC       IECB,IECB                 Reset ECB
         LA       R0,IIOBE                  Get ptr to IOBE
         EXCP     IIOB                      Start the read
         WAIT     ECB=IECB                  Wait for read to complete
*
* Test for unit exception (tape mark found)
*
         TM       IOBUSTAT,IOBUSB7          Unit exception? (Tape mark)
         BO       TMARK                     Yep, go handle tape mark
*
* Test for unit checks.  Just assumes end of data.
*
         TM       IOBUSTAT,IOBUSB6          Unit check? (Error (EOD))
         BO       IEOD                      Yes, go handle as EOD
*
* Test for good completion
*
         CLI      IOBUSTAT,IOBUSB4+IOBUSB5  Channel/Device End? (OK)
         BNE      IRDERR                    Nope, something unexpected
*
* Calculate actual length read
*
         XR       R4,R4                     Clear reg
         ICM      R4,B'0011',ICCWREAD+(CCW0CNT-CCW0) Requested length
         XR       R1,R1                     Clear reg
         ICM      R1,B'0011',IOBCSW+5       Get unread length
         SR       R4,R1                     Calc actual length
*
* Possible tape label?
*
         CL       R4,=F'80'                 Block length 80 bytes?
         BNE      RL01                      No, can't be a label
         L        R1,CPIBUFP                Get buffer pointer
         CLC      =C'VOL1',0(R1)            VOL1 label?
         BNE      RL01                      No, can't be a label
*
* Clearing IDRC indicator?
*
         TM       FLAGS,FLCII               Clear IDRC indicator?
         BNO      NCII0                     No, branch
         MVI      35(R1),C' '               Clear it
NCII0    DS       0H
*
* Grab a copy of the UCB volser (should probably use IEFDDSRV)
*
         TM       FLAGS,FLCVS               Check volser?
         BNO      RL01                      No, branch
         MVC      WTVOL,4(R1)               Remember the volser
         LA       R1,IDCB                   Get ptr to input DCB
         USING    IHADCB,R1                 Map DCB
         ICM      R1,B'0111',DCBDEBA        Get data extent
         DROP     R1                        Unmap DCB
         USING    DEBBASIC,R1               Map DEB
         ICM      R1,B'0111',DEBSUCBB       Get associated UCB
         DROP     R1                        Unmap DEB
         USING    UCBOB,R1                  Map UCB
         MVC      WUVOL,UCBVOLI             Copy the volser
         DROP     R1                        Unmap UCB
*
* Compare volsers
*
         CLC      WPVOL,WTVOL               Volser same as previous?
         BE       RL01                      Yes, must have been Ignored
         CLC      WUVOL,WTVOL               Volsers match?
         BE       RL01                      Yes, continue with loop
*
* Volsers don't match so ask operator what to do
*
W01      XC       WECB,WECB                 Reset ECB
         XC       WANSR,WANSR               Reset ansswer
         WTOR     TEXT=(WVDIF,WANSR,1,WECB),MF=(E,WTORL)
         WAIT     ECB=WECB,LONG=YES         Wait for reply
         CLI      WANSR,C'C'                Cancel?
         BE       BADVOL                    Yes, go handle it
         CLI      WANSR,C'I'                Ignore?
         BNE      W01                       No, bad reply...reprompt
         WTO      TEXT=WTIGN,MF=(E,WTOL)    Tell someone it was ignored
         MVC      WPVOL,WTVOL               Remember this volser
         B        RW01                      Reread in case tape changed
*
* Main processing loop
*
RLOOP    XC       IECB,IECB                 Reset ECB
         LA       R0,IIOBE                  Get ptr to IOBE
         EXCP     IIOB                      Start the read
         WAIT     ECB=IECB                  Wait for read to complete
*
* Test for unit exception (tape mark found)
*
         TM       IOBUSTAT,IOBUSB7          Unit exception? (Tape mark)
         BO       TMARK                     Yep, go handle tape mark
*
* Test for unit checks.  Just assumes end of data.
*
         TM       IOBUSTAT,IOBUSB6          Unit check? (Error (EOD))
         BO       IEOD                      Yes, go handle as EOD
*
* Test for good completion
*
         CLI      IOBUSTAT,IOBUSB4+IOBUSB5  Channel/Device End? (OK)
         BNE      IRDERR                    Nope, something unexpected
*
* Calculate actual length read
*
RL01     XR       R4,R4                     Clear reg
         ICM      R4,B'0011',ICCWREAD+(CCW0CNT-CCW0) Requested length
         XR       R1,R1                     Clear reg
         ICM      R1,B'0011',IOBCSW+5       Get unread length
         SR       R4,R1                     Calc actual length
*
* Maintain block count
*
         L        R1,CNTBLKS                Get block cnt
         LA       R1,1(R1)                  Bump
         ST       R1,CNTBLKS                Save it
*
* Maintain pre-compression stats
*
         CL       R4,CNTUMIN                Blklen > uncmp'd min len?
         BH       RL02                      Yes, keep old min blklen
         ST       R4,CNTUMIN                No, save new min blklen
RL02     CL       R4,CNTUMAX                Blklen < uncmp'd max len?
         BL       RL03                      Yes, keep old max blklen
         ST       R4,CNTUMAX                No, save new max blklen
RL03     L        R1,CNTUBYTE               Get uncmp'd byte cnt
         ALR      R1,R4                     Update
         ST       R1,CNTUBYTE               Save
*
* Possible tape label?
*
         CL       R4,=F'80'                 Block length 80 bytes?
         BNE      NCII1                     No, can't be a label
         L        R1,CPIBUFP                Get buffer pointer
         CLC      =C'HDR2',0(R1)            HDR2 label?
         BNE      NCII1                     No, can't be a label
*
* Clearing IDRC indicator?
*
         TM       FLAGS,FLCII               Clear IDRC indicator?
         BNO      NCII1                     No, branch
         CLI      34(R1),C'P'               Compacted?
         BNE      NCII1                     No, branch
         MVI      34(R1),C' '               Clear it
NCII1    DS       0H
*
* Compress data
*
         L        R5,CNTNCMP                Get not compressed cnt
         LA       R5,1(R5)                  Bump
         L        R3,CPIBUFP                Grab buffer ptr
         XC       HDRFLAG1,HDRFLAG1         Clear flags
         ICM      R15,B'1111',CPRTN         Compression requested?
         BZ       RL04                      No, so skip it
         ST       R4,CPILEN                 Store input length
         MVC      CPOLEN,=A(MAXBLK)         Init output length
         LA       R1,CPLIST                 Get parmlist pointer
         BALR     R14,R15                   Call routine
         LTR      R15,R15                   Good result?
         BNZ      CMPERR                    No, act like uncompressed
         C        R4,CPOLEN                 Did data length increase?
         BL       RL04                      Yes, act like uncompressed
*
* Verify compressed data
*
         TM       FLAGS,FLVER               Verify compression?
         BNO      NVER3                     No, go write data
         MVC      DCILEN,CPOLEN             Set input length
         MVC      DCOLEN,CPILEN             Set output length
         LA       R1,DCLIST                 Get parmlist pointer
         L        R15,DCRTN                 Decompression rtn ptr
         BALR     R14,R15                   Call routine
         LTR      R15,R15                   Good completion?
         BNZ      DCMPERR                   No, error
         #MEMCMP  *CPIBUFP,*DCOBUFP,(R4)    Compare blocks
         LTR      R15,R15                   Blocks equal?
         BNZ      DCMPERR                   No, go complain
NVER3    DS       0H
*
* Setup to output compressed data
*
         L        R4,CPOLEN                 Get output length
         L        R3,CPOBUFP                Get output pointer
         OC       HDRFLAG1,CPMETH+3         Set compression flags
         BCTR     R5,0                      Back off cnt
*
* Maintain post-compression stats
*
RL04     ST       R5,CNTNCMP                Save not compressed cnt
         CL       R4,CNTCMIN                Blklen > cmp'd min len?
         BH       RL05                      Yes, keep old min blklen
         ST       R4,CNTCMIN                No, save new min blklen
RL05     CL       R4,CNTCMAX                Blklen < cmp'd max len?
         BL       RL06                      Yes, keep old max blklen
         ST       R4,CNTCMAX                No, save new max blklen
RL06     L        R1,CNTCBYTE               Get cmp'd byte cnt
         ALR      R1,R4                     Update
         ST       R1,CNTCBYTE               Save
*
* Calc chunk size and set record flags accordingly
*
         OI       HDRFLAG1,HDRF1BOR         Set BOR flag
CLOOP    L        R5,CHKSZ                  Get maximum chunk size
         CR       R4,R5                     Input size bigger?
         BH       CL01                      Yep, only write chunk size
         LR       R5,R4                     Nope, write input size
         OI       HDRFLAG1,HDRF1EOR         Set EOR flag
*
* Write block header
*
CL01     MVC      HDRPRVLN,HDRCURLN         Copy previous block length
         STCM     R5,B'0001',HDRCURLN       Store low byte
         STCM     R5,B'0010',HDRCURLN+1     Store high byte
         MVC      ODCB+(DCBLRECL-IHADCB),=H'6' Set lrecl in DCB
         PUT      ODCB,HEADER               Write block header to ODCB
         NI       HDRFLAG1,255-HDRF1BOR     Turn off BOR flag
*
* Write input block in 32760 byte chunks
*
         L        R2,=F'32760'              Get chunk size
WLOOP    CR       R5,R2                     Input size bigger?
         BH       WL01                      Yep, only write chunk size
         LR       R2,R5                     Nope, write input size
WL01     STH      R2,ODCB+(DCBLRECL-IHADCB) Set lrecl in DCB
         PUT      ODCB,(R3)                 Write data block to ODCB
         AR       R3,R2                     Bump buffer ptr
         SR       R4,R2                     Calc remaining size
         SR       R5,R2                     Calc remaining size
         BNZ      WLOOP                     Continue if not zero
         LTR      R4,R4                     Any left in the block?
         BNZ      CLOOP                     Continue if not zero
         B        RLOOP                     Go back for next record
*
* Write tape mark header
*
TMARK    L        R1,CNTFILES               Get number of files
         LA       R1,1(R1)                  Add another
         ST       R1,CNTFILES               Save
         MVC      HDRPRVLN,HDRCURLN         Copy previous block length
         XC       HDRCURLN,HDRCURLN         Clear current block length
         MVI      HDRFLAG1,HDRF1TMK         Set tape mark flag
         MVC      ODCB+(DCBLRECL-IHADCB),=H'6' Set lrecl in DCB
         PUT      ODCB,HEADER               Write block header to ODCB
*        TM       FLAGS,FLSEOD              Start
*        TM       FLAGS,FLTM                Read a tapemark last time?
*        b
         B        RLOOP                     Go back for next record
*
* End of data reached on input
*
IEOD     CLOSE    (IDCB,,ODCB),MODE=31      Close DCBs
         FREEPOOL ODCB                      Free buffer pool
         FREEPOOL IDCB                      Free buffer pool
*
* Print stats
*
         #CALL    PRINTF,'Statistics:\n\n'
         #CALL    PRINTF,'  Files:                        %d\n',       X
               *CNTFILES
         #CALL    PRINTF,'  Blocks:                       %d\n',       X
               *CNTBLKS
         #CALL    PRINTF,'  Blocks not compressed:        %d\n',       X
               *CNTNCMP
         #CALL    PRINTF,'  Uncompressed bytes:           %d\n',       X
               *CNTUBYTE
         #CALL    PRINTF,'  Minimum uncompressed blksize: %d\n',       X
               *CNTUMIN
         #CALL    PRINTF,'  Maximum uncompressed blksize: %d\n',       X
               *CNTUMAX
         #CALL    PRINTF,'  Compressed bytes:             %d\n',       X
               *CNTCBYTE
         #CALL    PRINTF,'  Minimum compressed blksize:   %d\n',       X
               *CNTCMIN
         #CALL    PRINTF,'  Maximum compressed blksize:   %d\n',       X
               *CNTCMAX
*
* Display ending status, if requested
*
         TM       FLAGS,FLDES
         BNO      NDES1
         LA       R2,IIEDB
         USING    IEDB,R2
         #CALL    PRINTF,'  Ending status:\n'
         LM       R3,R4,IOBFLAG3
         #CALL    PRINTF,'    CSW:                        %08X %08X\n',X
               (R3),(R4)
         XR       R3,R3
         IC       R3,IEDBCOD
         #CALL    PRINTF,'    Completion code:            %02X\n',     X
               (R3)
         LM       R3,R6,IEDBSNS
         #CALL    PRINTF,'    Sense:                      %08X %08X %08X
               X %08X\n',(R3),(R4),(R5),(R6)
         LM       R3,R6,IEDBSNS+16
         #CALL    PRINTF,'                                %08X %08X %08X
               X %08X\n',(R3),(R4),(R5),(R6)
         DROP     R2
NDES1    XR       R15,R15                   Set good RC
         B        EXIT                      Get out of here
*
*----------------------------------------------------------------------
* Get blank delimited word
*
* In:    R1 = Ptr to start of scan (within PREC)
* Out:   R1 = Ptr to start of next scan
*        R3 = Ptr to start of word
*        R4 = Length of word - 1
*----------------------------------------------------------------------
GETWORD  DS       0H                        Entry
         LA       R2,PREC+L'PREC            Get ptr to end of record
         SLR      R2,R1                     Calc remaining length
         BP       BADPARM                   Zero, missing word
         BCTR     R2,0                      Back off for execute
         MVI      TRTABLE,C' '              Stop on any...
         MVC      TRTABLE+1(255),TRTABLE    ...character...
         MVI      TRTABLE+C' ',X'00'        ...other than blank
GW01     TRT      0(0,R1),TRTABLE           Executed
         EX       R2,GW01                   Find word
         BE       BADPARM                   Input exhausted, bad parm
         LR       R3,R1                     Save start of word
         LA       R2,PREC+L'PREC            Get ptr to end of record
         SLR      R2,R1                     Calc remaining length
         BCTR     R2,0                      Back off for execute
*
* Find end of word
*
         XC       TRTABLE,TRTABLE           Reset table
         MVI      TRTABLE+C' ',C' '         Stop on blank
         EX       R2,GW01                   Find end of word
         BNE      GW02                      Found it
         LA       R1,PREC+L'PREC            Get ptr to end of record
GW02     LR       R4,R1                     Get ptr to end of key
         SLR      R4,R3                     Calc length of key
         BCTR     R4,0                      Back off for execute
         BR       R10                       Return to caller
*
* Chunk size parameter validation routine
*
PRCS     CL       R2,=A(MINCHK)             Value < minimum chunk size?
         BL       PRCSE                     Yes, go tell user
         CL       R2,=A(MAXCHK)             Value > maximum chunk size?
         BH       PRCSE                     Yes, go tell user
         ST       R2,CHKSZ                  Save new chunk size
         BR       R10                       Return to caller
*
* Compression method parameter validation routine
*
PRCM     CL       R2,=A(MAXMTH)             Value > maximum method?
         BH       PRCME                     Yes, go tell user
         ST       R2,CPMETH                 Save method
         BR       R10                       Return to caller
*
* Compression level parameter validation routine
*
PRCL     CL       R2,=A(MINLVL)             Value < minimum level?
         BL       PRCLE                     Yes, go tell user
         CL       R2,=A(MAXLVL)             Value > maximum level?
         BH       PRCLE                     Yes, go tell user
         ST       R2,CPLVL                  Save new level
         BR       R10                       Return to caller
*
* Input DD name parameter validation routine
*
PRID     CL       R4,=A(L'DCBDDNAM-1)       Value length - 1 > 7
         BH       PRIDE                     Yes, go tell user
PRID01   MVC      IDCB+(DCBDDNAM-IHADCB)(0),0(R3) Executed
         EX       R4,PRID01                 Move over new DD name
         BR       R10                       Return to caller
*
* Output DD name parameter validation routine
*
PROD     CL       R4,=A(L'DCBDDNAM-1)       Value length - 1 > 7
         BH       PRODE                     Yes, go tell user
PROD01   MVC      ODCB+(DCBDDNAM-IHADCB)(0),0(R3) Executed
         EX       R4,PROD01                 Move over new DD name
         BR       R10                       Return to caller
*
* Verify compression parameter validation routine
*
PRVC     OI       FLAGS,FLVER               Indicate verification
         BR       R10                       Return to caller
*
* Check volser parameter validation routine
*
PRCV     NI       FLAGS,255-FLCVS           Assume FALSE
         LTR      R2,R2                     FALSE?
         BZR      R10                       Yes, just return
         OI       FLAGS,FLCVS               Set flag
         BR       R10                       Return to caller
*
* Clear IDRC indicator parameter validation routine
*
PRCI     NI       FLAGS,255-FLCII           Assume FALSE
         LTR      R2,R2                     FALSE?
         BZR      R10                       Yes, just return
         OI       FLAGS,FLCII               Set flag
         BR       R10                       Return to caller
*
* Display ending status validation routine
*
PRES     NI       FLAGS,255-FLDES           Assume FALSE
         LTR      R2,R2                     FALSE?
         BZR      R10                       Yes, just return
         OI       FLAGS,FLDES               Set flag
         BR       R10                       Return to caller
*
* Route code parameter validation routine
*
PRRC     CL       R2,=A(MINRCD)             Value < minimum route code?
         BL       PRRCE                     Yes, go tell user
         CL       R2,=A(MAXRCD)             Value > maximum route code?
         BH       PRRCE                     Yes, go tell user
         LA       R1,WTORL                  Get WTOR parm list
         USING    WPL,R1                    Map it
         OI       WPLMCSF1,WPLMCSFA         Turn on routing codes
         AH       R1,WPLLGH                 Point to WPX
         DROP     R1                        Unmap
         USING    WPX,R1                    Map it
         BCTR     R2,0                      Back off by one
         LR       R15,R2                    Get the code
         SRL      R15,3                     Get the byte index
         N        R2,=F'7'                  Isolate the bit
         LA       R15,WPXROUT(R15)          Addr of indexed byte
         LA       R2,MASKS(R2)              Addr of indexed mask
         OC       0(1,R15),0(R2)            Combine with existing codes
         DROP     R1                        Unmap
         BR       R10                       Return to caller
*
* Error routines
*
IOPERR   #CALL    PRINTF,'**ERR** Unable to open input DD\n'
         LA       R15,100                   Input open error
         B        EXIT                      Go exit
*
IRDERR   #CALL    PRINTF,'**ERR** Read error - IOB dump follows:\n'
         #CALL    PRINTF,                                              X
               'IOB %08X %08X %08X %08X\n   %08X %08X %08X %08X\n',    X
               *IIOB+00,*IIOB+04,*IIOB+08,*IIOB+12,                    X
               *IIOB+16,*IIOB+20,*IIOB+24,*IIOB+28
         LA       R15,101                   Read error
         B        EXIT                      Go exit
*
OOPERR   #CALL    PRINTF,'**ERR** Unable to open output DD\n'
         LA       R15,200                   Output open error
         B        EXIT                      Go exit
*
POPERR   #CALL    PRINTF,'**ERR** Unable to open SYSIN DD\n'
         LA       R15,300                   Parm open error
         B        EXIT                      Go exit
*
BADPARM  #CALL    PRINTF,'**ERR** Bad parameter encountered\n%s\n',    X
               (R3)
         LA       R15,400                   Bad parms detected
         B        EXIT                      Go exit
*
BADNUM   LA       R4,1(R4)
         #CALL    PRINTF,                                              X
               '**ERR** Parameter value %-*.*s must be numeric\n',     X
               (R4),(R4),(R3)
         LA       R15,401                   Bad parms detected
         B        EXIT                      Go exit
*
PRCSE    #CALL    PRINTF,'**ERR** Chunksize not within %d-%d\n',       X
               =A(MINCHK),=A(MAXCHK)
         LA       R15,402                   Chunk size out of range
         B        EXIT                      Go exit
*
PRCME    #CALL    PRINTF,                                              X
               '**ERR** Method must be 1 (ZLIB) or 2 (BZLIB)\n'
         LA       R15,403                   Method out of range
         B        EXIT                      Go exit
*
PRCLE    #CALL    PRINTF,'**ERR** Level must be within 1-9\n'
         LA       R15,404                   Level out of range
         B        EXIT                      Go exit
*
PRIDE    #CALL    PRINTF,'**ERR** Input DD name too long\n'
         LA       R15,405                   Input DD name too long
         B        EXIT                      Go exit
*
PRODE    #CALL    PRINTF,'**ERR** Output DD name too long\n'
         LA       R15,406                   Output DD name too long
         B        EXIT                      Go exit
*
BADBOOL  LA       R4,1(R4)
         #CALL    PRINTF,                                              X
               '**ERR** Parameter value %-*.*s must be YES or NO\n',   X
               (R4),(R4),(R3)
         LA       R15,407                   Bad parms detected
         B        EXIT                      Go exit
*
BADVOL   #CALL    PRINTF,                                              X
               '**ERR** Volser mismatch - requested %-6.6s, actual %-6.X
               6s\n',                                                  X
               =A(WUVOL),=A(WTVOL)
         LA       R15,408                   UCB retrieval failed
         B        EXIT                      Go exit
*
PRRCE    #CALL    PRINTF,'**ERR** Route code not within %d-%d\n',      X
               =A(MINRCD),=A(MAXRCD)
         LA       R15,409                   Route code out of range
         B        EXIT                      Go exit
*
CMPERR   LR       R2,R15                    Get compression RC
         #CALL    PRINTF,'**ERR** Compression failed: %d\n',(R2)
         LA       R15,500                   Compression failed
         B        EXIT                      Go exit
*
DCMPERR  LR       R2,R15                    Get decompression RC
         #CALL    PRINTF,'**ERR** Decompressed data invalid: %d\n',(R2)
         LA       R15,501                   Decompression failed
         B        EXIT                      Go exit
*
CPRERR   #CALL    PRINTF,'**ERR** Data blocks unequal\n'
         LA       R15,502                   Data blocks unequal
         B        EXIT                      Go exit
*
* Free the buffer storage
*
EXIT     LR       R2,R15                    Save RC
         #CALL    FREE,*CPIBUFP             Compression input buffer
         #CALL    FREE,*CPOBUFP             Compression output buffer
         TM       FLAGS,FLVER               Verifying compression?
         BNO      NVER4                     No, don't free buffer
         #CALL    FREE,*DCOBUFP             Decompression output buffer
NVER4    LTR      R15,R2                    Restore RC and test
         BZ       RETURN                    No error, so just exit
         TM       FLAGS,FLAE                Abend?
         BNO      RETURN                    No, just return CC
         ABEND    (R15)                     Kaboom
RETURN   #EPILOG                            Return to caller
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
*
*----------------------------------------------------------------------
* Static data
*----------------------------------------------------------------------
MASKS    DC       X'80,40,20,10,08,04,02,01' bit masks
*
* Parameter types
*
PTNUM    EQU      X'01'                     Numeric parameter
PTSTR    EQU      X'02'                     String parameter
PTBOOL   EQU      X'04'                     Boolean (0 or 1) parameter
*
* Parameter table
*
PTABLE   DS       0A
         DC       A(PS01),A(PRCM),AL2(L'PS01-1),AL1(PTNUM),X'00'
         DC       A(PS02),A(PRCL),AL2(L'PS02-1),AL1(PTNUM),X'00'
         DC       A(PS03),A(PRID),AL2(L'PS03-1),AL1(PTSTR),X'00'
         DC       A(PS04),A(PROD),AL2(L'PS04-1),AL1(PTSTR),X'00'
         DC       A(PS05),A(PRCS),AL2(L'PS05-1),AL1(PTNUM),X'00'
         DC       A(PS06),A(PRVC),AL2(L'PS06-1),AL1(PTBOOL),X'00'
         DC       A(PS07),A(PRCV),AL2(L'PS07-1),AL1(PTBOOL),X'00'
         DC       A(PS08),A(PRCI),AL2(L'PS08-1),AL1(PTBOOL),X'00'
         DC       A(PS09),A(PRES),AL2(L'PS09-1),AL1(PTBOOL),X'00'
         DC       A(PS10),A(PRRC),AL2(L'PS10-1),AL1(PTNUM),X'00'
         DC       A(0)
PS01     DC       C'COMPRESSION_METHOD'
PS02     DC       C'COMPRESSION_LEVEL'
PS03     DC       C'INPUT_DDNAME'
PS04     DC       C'OUTPUT_DDNAME'
PS05     DC       C'CHUNK_SIZE'
PS06     DC       C'VERIFY_COMPRESSION'
PS07     DC       C'CHECK_VOLSER'
PS08     DC       C'CLEAR_IDRC_INDICATOR'
PS09     DC       C'DISPLAY_ENDING_STATUS'
PS10     DC       C'ROUTE_CODE'
         LTORG                              Store literals
*
*----------------------------------------------------------------------
* Drop base registers
*----------------------------------------------------------------------
         DROP     R9,R11,R12                Drop bases
*
*----------------------------------------------------------------------
* Volatile data.
*----------------------------------------------------------------------
*
* HET block header
*
HEADER   DS       0CL6                      Block header
HDRCURLN DC       XL2'0000'                 Current block length
HDRPRVLN DC       XL2'0000'                 Previous block length
HDRFLAG1 DC       X'00'                     Flags byte 1...
HDRF1BOR EQU      X'80'                     ...beginning of record
HDRF1TMK EQU      X'40'                     ...tape mark
HDRF1EOR EQU      X'20'                     ...end of record
HDRF1CMP EQU      X'03'                     ...compression flags
HDRFLAG2 DC       X'00'                     Flags byte 2
HDRLEN   EQU      *-HEADER                  Header length
*
* Misc. Flags
*
FLAGS    DC       AL1((FLVER*DEFVER)+(FLCVS*DEFCVS)) Flags
FLAGSAVE DC       X'00'                     Saved copy of flags
FLEOD    EQU      X'80'                     End of data reached
FLEOV    EQU      X'40'                     End of volume reached
FLTM     EQU      X'20'                     Tape mark read
FLVER    EQU      X'10'                     Verify compression
FLCVS    EQU      X'08'                     Check volser
FLCII    EQU      X'04'                     Clear IDRC indicator
FLAE     EQU      X'02'                     Abend if error occurs
FLDES    EQU      X'01'                     Display ending status
*
* Compression parameter list
*
CPRTN    DC       A(0)                      Compression routine
CPLIST   DS       0A      ZLIB      BZLIB   Compression parameter list
CPOBUFP  DC       A(0)   <------  <------   Output buffer ptr
CPOLENP  DC       A(CPOLEN)    |        |   Output length ptr
CPIBUFP  DC       A(0)         |        |   Input buffer ptr
CPILEN   DC       F'0'         |        |   Input length
CPLVL    DC       A(DEFLVL) <---        |   Compression level
CPVERB   DC       F'0'                  |   Verbosity
CPWORK   DC       F'0'  <----------------   Work factor
CPOLEN   DC       F'0'                      Length of compressed data
CPTAB    DC       A(0,ZCMP2,BZBUFFC)        Compression routine table
CPMETH   DC       A(DEFMTH)                 Compression method
*
* Decompression parameter list
*
DCRTN    DC       A(0)                      Decompression routine
DCLIST   DS       0A      ZLIB      BZLIB   Decompression parm list
DCOBUFP  DC       A(0)   <------  <------   Output buffer ptr
DCOLENP  DC       A(DCOLEN)    |        |   Output length ptr
DCIBUFP  DC       A(0)         |        |   Input buffer ptr
DCILEN   DC       F'0'      <---        |   Input length
DCSMALL  DC       F'0'                  |   Decompression memory model
DCVERB   DC       F'0'  <----------------   Verbosity
DCOLEN   DC       F'0'                      Length of compressed data
DCTAB    DC       A(0,ZUNCMP,BZBUFFD)       Decompression routine table
*
* Misc. work fields
*
CNTUBYTE DC       F'0'                      Uncomp'd bytes
CNTUMIN  DC       F'-1'                     Uncomp'd minimum block size
CNTUMAX  DC       F'0'                      Uncomp'd maximum block size
CNTCBYTE DC       F'0'                      Comp'd bytes
CNTCMIN  DC       F'-1'                     Comp'd minimum block size
CNTCMAX  DC       F'0'                      Comp'd maximum block size
CNTNCMP  DC       F'0'                      Not comp'd block count
CNTBLKS  DC       F'0'                      Block count
CNTFILES DC       F'0'                      File count
CHKSZ    DC       A(MAXCHK)                 Chunk size
PVALP    DC       D'0'                      Numeric work area
PREC     DC       CL80' '                   Parameter input record
TRTABLE  DC       CL256'00'                 Translation table
*
* Data Control Blocks
*
PDCB     DCB      DSORG=PS,MACRF=GM,DDNAME=SYSIN,LRECL=80,EODAD=PEOF
IDCB     DCB      DEVD=TA,DSORG=PS,MACRF=E,DDNAME=IDCB,IMSK=00000000
ODCB     DCB      DSORG=PS,MACRF=PM,DDNAME=ODCB,                       X
               RECFM=U,LRECL=0,BLKSIZE=32760
*
* CCWs
*
ICCWREW  CCW      X'07',0,CCW0SLI,1         Rewind tape
ICCWREAD CCW      X'02',0,CCW0SLI,MAXBLK    Read tape
*
* Input ECB
*
IECB     DC       F'0'                      Event Control Block
*
* Intialize the Input/Output Block (IOB)
*
         DS       0F                        Align
IIOB     DC       XL(IOBEXTEN-IOBSTDRD)'00' Initialize IOB
         ORG      IIOB+(IOBFLAG1-IOBSTDRD)  Adjust origin
         DC       AL1(IOBUNREL)             Set IOBFLAG1
         ORG      IIOB+(IOBECBPT-IOBSTDRD)  Adjust origin
         DC       A(IECB)                   Set ECB ptr
         ORG      IIOB+(IOBSTART-IOBSTDRD)  Adjust origin
         DC       A(ICCWREW)                Set CCW ptr
         ORG      IIOB+(IOBDCBPT-IOBSTDRD)  Adjust origin <--- Leave
         DC       A(IDCB)                   Set DCB ptr      | in
         ORG      IIOB+(IOBFLAG4-IOBSTDRD)  Adjust origin    | this
         DC       AL1(IOBCEF)               Set IOBFLAG4  <--- order
         ORG      IIOB+(IOBINCAM-IOBSTDRD)  Adjust origin
         DC       H'1'                      Set block increment
         ORG
*
* Intialize the Input/Output Block Extension (IOBE)
*
         DS       0F                        Align
IIOBE    DC       XL(IOBELNTH)'00'          Initialize IOBE
         ORG      IIOBE+(IOBEID-IOBE)       Adjust origin
         DC       C'IOBE'                   Set eyecatcher
         ORG      IIOBE+(IOBEVERS-IOBE)     Adjust origin
         DC       AL1(IOBEVRSC)             Set version
         ORG      IIOBE+(IOBEIEDB-IOBE)     Adjust origin
         DC       A(IIEDB)                  Set EDB ptr
         ORG
*
* Intialize the Input/Output Error Data Block (IEDB)
*
         DS       0F                        Align
IIEDB    DC       XL(IEDBLNTH)'00'          Initialize IEDB
         ORG      IIEDB+(IEDBID-IEDB)       Adjust origin
         DC       C'IEDB'                   Set eyecatcher
         ORG      IIEDB+(IEDBVERS-IEDB)     Adjust origin
         DC       AL1(IEDBVRSC)             Set version
         ORG
*
* WTO(R) data
*
WTORL    WTOR     TEXT=(,,,),ROUTCDE=,MF=L  WTOR parameter list
WTOL     WTO      TEXT=,ROUTCDE=,MF=L       WTO parameter list
WECB     DC       F'0'                      Event Control Block
WANSR    DC       C'N'                      Answer
WVDIF    DC       AL2(WTEXTL)               Length of message
WTEXT    DC       C'HETUTL '                Message...
WTVOL    DC       C'tttttt'                 ...Volser from tape...
         DC       C' mounted for '          ...
WUVOL    DC       C'uuuuuu'                 ...Volser from UCB...
         DC       C'.  Reply (I)gnore or (C)ancel' ...
WTEXTL   EQU      *-WTEXT                   Length
WPVOL    DC       XL6'00'                   Saved volser for ignore
*
* WTO data
*
WTIGN    DC       AL2(WTIGNL)               Message length
WTIGNT   DC       C'HETUTL Volser mismatch ignored' Message
WTIGNL   EQU      *-WTIGNT                  Length
*
* Various DSECTs
*
         PRINT    ON
         DCBD     DSORG=PS,DEVD=TA
         IECDRQE
         IEZDEB
         IEZIOB
         IHAECB
         IOSDCCW
         IOSDIOBE
         IOSDIEDB
         IEFUCBOB DEVCLAS=MT
         IEZWPL
         PRINT    ON
         END      HETUTL
